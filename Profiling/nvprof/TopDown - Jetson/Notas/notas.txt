Back End Bound: Impactos en la jerarquía de memoria.

    - Memory Bound: Límites derivados de la jerarquía de memoria, eg. accesos a la memoria cache.
    - Core Bound: Límites derivados por operaciones, eg, retardos derivados por bloqueos en el pipeline devidos a una división
                  que tarda muchos ciclos.

------------------------------------ Memory Bound --------------------------------------------------------------------------
Memorias cache:
    - Instruction Cache: Cache de instrucciones. NO forma parte del BackEnd, sino del FrontEnd. De hecho, formaría parte de los
        contadores del frontend: Retrasos por no tener las intrucciones en la cache. 
    - Texture / L1 Cache: Memoria caché privada al SM. Disponible también para texturas.
    - L2: Memoria caché compartida por todos los SMs. 

Espacios de Memoria: Estos forman parte de la VRAM de la GPU.
    - Local: Privada al thread con variables no aptas para registros (arrays)
    - Shared: Privada al bloque de threads (gestionada por el programador).
    - Global: Visible por todos los threads. Cambios que realiza un thread son vistos por los demás threads.
    - Constant: Visible por todos los threads (parámetros pasados al kernel por valor). Cambios que realiza un thread NO vistos por
    los demas.

    
------------------------------------ End Memory Bound --------------------------------------------------------------------------

stall_inst_fetch:  Percentage of stalls occurring because the next assembly instruction has not yet been fetched

stall_exec_dependency:  Percentage of stalls occurring because an input required by the instruction is not yet available

stall_memory_dependency:  Percentage of stalls occurring because a memory operation cannot be performed due to the required resources not being available or fully utilized, or because too many requests of a given type are outstanding

stall_texture:  Percentage of stalls occurring because the texture sub-system is fully utilized or has too many outstanding requests

stall_sync:  Percentage of stalls occurring because the warp is blocked at a __syncthreads() call

stall_other:  Percentage of stalls occurring due to miscellaneous reasons

stall_constant_memory_dependency:  Percentage of stalls occurring because of immediate constant cache miss

stall_pipe_busy:  Percentage of stalls occurring because a compute operation cannot be performed because the compute pipeline is busy

stall_memory_throttle:  Percentage of stalls occurring because of memory throttle

stall_not_selected:  Percentage of stalls occurring because warp was not selected


CLAVE: https://docs.nvidia.com/gameworks/content/developertools/desktop/analysis/report/cudaexperiments/kernellevel/issueefficiency.htm#IssueStallReasons
Other: https://stackoverflow.com/questions/14887807/what-are-other-issue-stall-reasons-displayed-by-the-nsight-profiler
-------------------------------------------------------------------------- EXPLICACION CONTADORES --------------------------------------------

- stall_inst_fetch: STALLS producidos porque no se ha podido realizar el fetch de una instrucción. Esto por ejemplo es debido a no tener una instrucción en la caché de instrucciones,
		    por lo que habría que descender en la jerarquía de memoria. CASO: Si tienes bucles que son lo suficientemente largos como para no caber en la caché de instrucciones, eso podría 			    resultar en problemas de fetch de instrucciones.

- stall_exec_dependency: Una entrada requerida por la instrucción aún no está disponible. Los bloqueos de dependencia de ejecución se pueden reducir potencialmente aumentando el paralelismo a nivel 				 de instrucción (NVIDIA). Dependencias RAW. NO entiendo porque con paralelismo a nivel de instrucción se soluciona... La solución más sencilla sería reordenamiento de 			 instrucciones, para evitar dependencias RAW...

- stall_memory_dependency: No se puede realizar una load/store porque los recursos necesarios no están disponibles o se utilizan por completo, o hay demasiadas solicitudes pendientes de un tipo 				   determinado. Los bloqueos de dependencia de la memoria se pueden reducir potencialmente optimizando la alineación de la memoria y los patrones de acceso.

			   Operaciones:
			   	- Lectura: Por ejemplo, los datos no están en la memoria CACHE (ni L1, ni L2), por lo que hay que ir a la VRAM.
			   	- Escritura: Problemas de Escritura... 
			   # REVISAR ESTE... QUIZÁ lo mejor sea hacer programas de prueba

- stall_texture:	# NOT USED

- stall_sync:		STALLS ocurridos porque un WARP (perteneciente al bloque de threads X) está bloqueado en '__syncthreads()' esperando a que todos los WARPS del bloque X lleguen a la función.

- stall_other:		"Diversos motivos" Link: https://stackoverflow.com/questions/14887807/what-are-other-issue-stall-reasons-displayed-by-the-nsight-profiler
			 - Compute Capability 3.*:
			 	- ...
			 - Compute Capability 5.* and 6.*: # La 'compute capability' de PASCAL es la 6.0
			 	- Conflictos banco registros (problema del compilador que a veces puede empeorar por el uso intensivo de tipos de datos vectoriales).
			 	- WARPS esperando a resolver saltos.
			 	- warps que tienen menor prioridad y que actualmente no se están considerando para la programación.

			Compute Capability: La capacidad de cálculo es el "conjunto de características" (características de hardware y software) del dispositivo.


- stall_constant_memory_dependency: Porcentaje de STALLS ocurridos debido a fallos inmediatos de cache constante. 

- stall_pipe_busy: STALLS provocados porque no se disponen de unidades funcionales suficientes para poder realizar una operación. Por ejemplo, un WARP entero
                   va a realizar una operación X de la que se disponen menos del tamaño del WARP de UF para esa operación. Algunos threads la podrán hacer
                   pero otros no, que tendrán que esperar.

- stall_memory_throttle: STALLS producidos por la reducción del rendimiento de la memoria por altas temperaturas.

- stall_not_selected: Stalls ocurridos porque un WARP elegible no ha sido seleccionado. 

-------------------------------------------------------------------------- END EXPLICACION CONTADORES --------------------------------------------

-------------------------- ASIGNACION NIVEL 1 ------------------------------------------------------------------------------------------
- FrontEnd: stall_inst_fetch, stall_exec_dependency, stall_sync, stall_other, stall_not_selected

- BackEnd: stall_memory_dependency, stall_constant_memory_dependency, stall_pipe_busy, stall_memory_throttle
-------------------------- END ASIGNACION NIVEL 1 ------------------------------------------------------------------------------------------
