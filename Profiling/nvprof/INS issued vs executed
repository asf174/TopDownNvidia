Replays are a technique employed by a multi-threaded processor to avoid stalling the pipeline when a long latency event occurs. When an instruction is issued, pipelined processors will continue to issue instructions behind it as long as they do not depend on the issued instruction, or the dependencies can be resolved by forwarding results. This is fine in most cases, the original instruction will be executed quickly and the pipeline will continue to process instructions. However, sometimes the original instruction can encounter a long latency event where it cannot complete quickly (it may be a load that misses in the cache, there may be a conflict for a shared port, etc). In these cases, simple processors may just stall the pipeline. This is fine for single threaded, in-order processors, but it is bad for multi-threaded processors because there are usually independent instructions from different threads that can be executed immediately without waiting. In this case you really want the long latency instruction to ‘get out of the way’. Replays help in this case by squashing the instructions in the pipeline and beginning executing instructions from a different thread. The original instruction will be ‘replayed’ again at some later time, hopefully at which time it will execute quickly. Some time is wasted because instructions are squashed, but it is typically on the order of a few instructions, rather than the hundreds of cycles that would be needed to wait for a cache miss.

----------------------------------------------------

Las repeticiones son una técnica empleada por un procesador de subprocesos múltiples para evitar estancar la canalización cuando ocurre un evento de latencia prolongada. Cuando se emite una instrucción, los procesadores interconectados seguirán emitiendo instrucciones detrás de ella siempre que no dependan de la instrucción emitida, o las dependencias se pueden resolver enviando resultados. Esto está bien en la mayoría de los casos, la instrucción original se ejecutará rápidamente y la canalización continuará procesando instrucciones. Sin embargo, a veces la instrucción original puede encontrar un evento de latencia prolongada donde no se puede completar rápidamente (puede ser una carga que no se encuentra en la caché, puede haber un conflicto para un puerto compartido, etc.). En estos casos, los procesadores simples pueden detener la tubería. Esto está bien para los procesadores en orden de un solo subproceso, pero es malo para los procesadores de subprocesos múltiples porque generalmente hay instrucciones independientes de diferentes subprocesos que se pueden ejecutar inmediatamente sin esperar. En este caso, realmente desea que la instrucción de latencia larga "salga del camino". Las repeticiones ayudan en este caso al aplastar las instrucciones en la canalización y comenzar a ejecutar instrucciones desde un hilo diferente. La instrucción original se "reproducirá" de nuevo más adelante, con suerte, en ese momento se ejecutará rápidamente. Se pierde algo de tiempo porque las instrucciones se reducen, pero normalmente es del orden de unas pocas instrucciones, en lugar de los cientos de ciclos que se necesitarían para esperar a que se pierda la caché. 
