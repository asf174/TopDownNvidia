from measure_levels.level_two import LevelTwo
from measure_levels.level_one_nsight import LevelOneNsight

class LevelTwoNsight(LevelTwo, LevelOneNsight):

    def _get_results(self, lst_output : list):
        """ 
        Get results of the different parts.

        Parameters:
            lst_output              : list     ; OUTPUT list with results
        """

        # revisar en unos usa atributo y en otros la llamada al metodo
        #  Keep Results
        converter : MessageFormat = MessageFormat()
        if not self._recolect_metrics:
            return
        if self._recolect_metrics and self._front_end.metrics_str() != "":
            lst_output.append(converter.underlined_str(self._front_end.name()))
            super()._add_result_part_to_lst(self._front_end.metrics(), 
                self._front_end.metrics_description(), lst_output, True)
        if  self._recolect_metrics and self._front_band_width.metrics_str() != "":
            lst_output.append(converter.underlined_str(self._front_band_width.name()))
            super()._add_result_part_to_lst(self._front_band_width.metrics(), 
                self._front_band_width.metrics_description(), lst_output, True)
        if self._recolect_metrics and self._front_dependency.metrics_str() != "":
            lst_output.append(converter.underlined_str(self._front_dependency.name()))
            super()._add_result_part_to_lst(self._front_dependency.metrics(), 
                self._front_dependency.metrics_description(), lst_output, True)
        if self._recolect_metrics and self._back_end.metrics_str() != "":
            lst_output.append(converter.underlined_str(self._back_end.name()))
            super()._add_result_part_to_lst(self._back_end.metrics(), 
                self._back_end.metrics_description(), lst_output, True)
        if self._recolect_metrics and self._back_core_bound.metrics_str() != "":
            lst_output.append(converter.underlined_str(self._back_core_bound.name()))
            super()._add_result_part_to_lst(self._back_core_bound.metrics(), 
                self._back_core_bound.metrics_description(), lst_output, True)
        if self._recolect_metrics and self._back_memory_bound.metrics_str() != "":
            lst_output.append(converter.underlined_str(self._back_memory_bound.name()))
            super()._add_result_part_to_lst(self._back_memory_bound.metrics(), 
                self._back_memory_bound.metrics_description(), lst_output, True)
        if self._recolect_metrics and self._divergence.metrics_str() != "":
            lst_output.append(converter.underlined_str(self._divergence.name()))
            super()._add_result_part_to_lst(self._divergence.metrics(), 
                self._divergence.metrics_description(), lst_output, True)
        if self._recolect_metrics and  self._retire.metrics_str() != "":
                lst_output.append(converter.underlined_str(self._retire.name()))
                super()._add_result_part_to_lst(self._retire.metrics(), 
                self._retire.metrics_description(), lst_output, True)
        if self._recolect_metrics and self._extra_measure.metrics_str() != "":
            lst_output.append(converter.underlined_str(self._extra_measure.name()))
            super()._add_result_part_to_lst(self._extra_measure.metrics(), 
                self._extra_measure.metrics_description(), lst_output, True)
        lst_output.append("\n")
        pass

    pass

    def _set_memory_core_bandwith_dependency_results(self, results_launch : str):
        """
        Set results of the level two part (that are not level one).
        
        Params:
            results_launch : str   ; results generated by NVIDIA scan tool.
        """
    
    def _set_front_back_divergence_retire_results(self, results_launch : str):
        """ Get Results from FrontEnd, BanckEnd, Divergence and Retire parts.
        
        Params:
            results_launch  : str   ; results generated by NVIDIA scan tool
            
        Raises:
            MetricNotAsignedToPart      ; raised when a metric has not been assigned to any analysis part
        """

        metric_name : str
        metric_unit : str
        metric_value : str
        line : str
        i : int
        list_words : list
        front_end_value_has_found : bool
        frond_end_unit_has_found : bool
        back_end_value_has_found : bool
        back_end_unit_has_found : bool
        divergence_value_has_found : bool
        divergence_unit_has_found : bool
        extra_measure_value_has_found : bool
        extra_measure_unit_has_found : bool
        retire_value_has_found : bool
        retire_unit_has_found : bool
        can_read_results : bool = False
        for line in str(results_launch).splitlines():
            line = re.sub(' +', ' ', line) # delete more than one spaces and put only one
            list_words = line.split(" ")
            # Check if it's line of interest:
            # ['', 'metric_name','metric_unit', 'metric_value']
            if not can_read_results:
                if list_words[0] == "==PROF==" and list_words[1] == "Disconnected":
                        can_read_results = True
                continue
            if (len(list_words) == 4 or len(list_words) == 3) and list_words[1][0] != "-":
                if len(list_words) == 3:
                    metric_name = list_words[1]
                    metric_unit = ""
                    metric_value = list_words[2]
                else:
                    metric_name = list_words[1]
                    metric_unit = list_words[2]
                    metric_value = list_words[3]
                back_core_bound_value_has_found = self._back_core_bound.set_metric_value(metric_name, metric_value)
                back_core_bound_unit_has_found = self._back_core_bound.set_metric_unit(metric_name, metric_unit)
                back_memory_bound_value_has_found = self._back_memory_bound.set_metric_value(metric_name, metric_value)
                back_memory_bound_unit_has_found = self._back_memory_bound.set_metric_unit(metric_name, metric_unit)
                front_band_width_value_has_found = self._front_band_width.set_metric_value(metric_name, metric_value)
                front_band_width_unit_has_found = self._front_band_width.set_metric_unit(metric_name, metric_unit)
                front_dependency_value_has_found = self._front_dependency.set_metric_value(metric_name, metric_value)
                front_dependency_unit_has_found = self._front_dependency.set_metric_unit(metric_name, metric_unit)
                if (not (back_core_bound_value_has_found or back_memory_bound_value_has_found or front_band_width_value_has_found
                    or front_dependency_value_has_found) or not(back_core_bound_unit_has_found or back_memory_bound_unit_has_found
                    or front_band_width_unit_has_found or front_dependency_unit_has_found)):
                    if not self.__metricExists(metric_name):
                        raise MetricNotAsignedToPart(metric_name)

        pass

